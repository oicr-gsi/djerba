<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>djerba.genetic_alteration API documentation</title>
<meta name="description" content="Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>djerba.genetic_alteration</code></h1>
</header>
<section id="section-intro">
<p>Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal.</p>
<p>A <code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code> object reads input from files, database queries, etc.; parses sample-level and gene-level attributes; and returns them in standard data structures.</p>
<p>Includes:</p>
<ul>
<li><code>genetic alteration</code>: Abstract base class</li>
<li>Subclasses to implement genetic_alteration methods for particular data types</li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory" href="#djerba.genetic_alteration.genetic_alteration_factory">genetic_alteration_factory</a></code>: Class to construct an instance of an appropriate <code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code> subclass, given its name and other configuration data.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal.

A `genetic_alteration` object reads input from files, database queries, etc.; parses sample-level and gene-level attributes; and returns them in standard data structures.

Includes:

- `genetic alteration`: Abstract base class
- Subclasses to implement genetic_alteration methods for particular data types
- `genetic_alteration_factory`: Class to construct an instance of an appropriate `genetic_alteration` subclass, given its name and other configuration data.
&#34;&#34;&#34;

import logging
import os
import pandas as pd
import random
import tempfile
import yaml
from djerba.metrics import mutation_extended_metrics
from djerba.utilities import constants
from djerba.utilities.base import base
from djerba.utilities.tools import system_tools

class genetic_alteration(base):
    &#34;&#34;&#34;Base class; unit of genetic alteration data for cBioPortal and other reports&#34;&#34;&#34;

    # TODO make into a Python AbstractBaseClass: https://docs.python.org/3/library/abc.html

    # top-level config keys
    WORKFLOW_RUN_ID_KEY = &#39;workflow_run_id&#39;
    METADATA_KEY = &#39;metadata&#39;
    INPUT_FILES_KEY = &#39;input_files&#39;
    INPUT_DIRECTORY_KEY = &#39;input_directory&#39;
    # additional metadata keys
    FILTER_VCF_KEY = &#39;filter_vcf&#39;
    REGIONS_BED_KEY = &#39;regions_bed&#39;
    
    def __init__(self, config, study_id=None, log_level=logging.WARNING, log_path=None):
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)
        self.study_id = study_id # required for cBioPortal, not for Elba
        try:
            self.genetic_alteration_type = config[constants.GENETIC_ALTERATION_TYPE_KEY]
            self.datatype = config[constants.DATATYPE_KEY]
            self.metadata = config[self.METADATA_KEY]
            self.input_files = config[self.INPUT_FILES_KEY]
            self.input_directory = config[self.INPUT_DIRECTORY_KEY]
            self.workflow_run_id = config[self.WORKFLOW_RUN_ID_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        self.sample_ids = self._get_sample_ids()
        self.sample_attributes = self._find_all_sample_attributes()
        # identifier for the genetic_alteration; should be unique in any given config
        self.alteration_id = &#34;%s:%s&#34; % (self.genetic_alteration_type, self.datatype)
        self.gene_names = None # used to cache the gene names

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;PLACEHOLDER. Read self.input_files and populate a sample attributes dictionary&#34;&#34;&#34;
        msg = &#34;_find_all_sample_attributes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        attributes = {}
        for sample_id in self.sample_ids:
            attributes[sample_id] = {}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;
        Find the list of sample IDs. Assumes the input_files config is non-empty.
        Optionally, can override this method in child classes.
        &#34;&#34;&#34;
        return sorted(self.input_files.keys())

    def get_alteration_id(self):
        &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
        return self.alteration_id

    def get_attributes_for_sample(self, sample_id):
        &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
        return self.sample_attributes[sample_id]

    def get_datatype(self):
        return self.datatype

    def get_genetic_alteration_type(self):
        return self.genetic_alteration_type

    def get_gene_names(self):
        &#34;&#34;&#34;
        PLACEHOLDER. Get a list of gene names from the input files.
        Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
        &#34;&#34;&#34;
        msg = &#34;get_genes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        return []

    def get_input_path(self, sample_id):
        return os.path.join(self.input_directory, self.input_files[sample_id])
    
    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
        msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
        self.logger.error(msg)
        return {}

    def get_sample_ids(self):
        return self.sample_ids


class genetic_alteration_factory(base):
    &#34;&#34;&#34;Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE&#34;&#34;&#34;

    CLASSNAMES = {
        constants.CUSTOM_ANNOTATION_TYPE: &#39;custom_annotation&#39;,
        constants.MUTATION_TYPE: &#39;mutation_extended&#39;
    }

    def __init__(self, log_level=logging.WARN, log_path=None):
        self.log_level = log_level
        self.log_path = log_path
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)

    def create_instance(self, config, study_id=None):
        &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
        alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
        classname = self.CLASSNAMES.get(alteration_type)
        if alteration_type == None or classname == None:
            msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
            msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
            self.logger.error(msg)
            raise ValueError(msg)
        klass = globals().get(classname)
        return klass(config, study_id, self.log_level, self.log_path)

class custom_annotation(genetic_alteration):
    &#34;&#34;&#34;
    User-defined custom annotation supplied in TSV format.

    ## Input requirements

    - Input is in separate TSV files for gene and sample annotation.
    - Gene and sample filenames are specified in metadata, as &#39;gene_tsv&#39; and &#39;sample_tsv&#39; respectively.
    - Input files are tab-delimited, and may include comment lines starting with #.
    - Annotations which contain tab characters may be enclosed in double quotes (&#34;).
    - Column headers in the gene and sample files must be specified in config metadata, as &#39;gene_headers&#39; and &#39;sample_headers&#39; respectively.
    - The first column must be the gene or sample identifier, with header &#39;Gene&#39; or &#39;SAMPLE_ID&#39; respectively.
    - If column headers from metadata are not found in the TSV file, it will raise an error.
    - Columns in the TSV file which do not appear in metadata are silently ignored.

    ## Notes

    - Useful as a fallback for fields which cannot be automatically obtained by Djerba.
    - Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    GENE_HEADERS_KEY = &#39;gene_headers&#39;
    GENE_TSV_KEY = &#39;gene_tsv&#39;
    SAMPLE_HEADERS_KEY = &#39;sample_headers&#39;
    SAMPLE_TSV_KEY = &#39;sample_tsv&#39;

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Read attributes for each sample from a TSV file with specified headers&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
            column_headers = self.metadata[self.SAMPLE_HEADERS_KEY] # must start with SAMPLE_ID_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        # row.to_list() is a workaround for int64 conversion; see comments in get_metrics_by_gene
        for (sample_id, row) in self._read_columns(tsv_path, column_headers).iterrows():
            values = row.to_list()
            attributes[sample_id] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;Read sample IDs from TSV input file; overrides method of parent class&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.SAMPLE_ID_KEY], index_col=False)
        return df[constants.SAMPLE_ID_KEY].tolist()

    def _read_columns(self, input_path, column_headers, index_col=0):
        &#34;&#34;&#34;
        Read specified columns from TSV into a Pandas DataFrame.
        Raise an error if any requested columns are missing; warn if any values are null.
        &#34;&#34;&#34;
        try:
            df = pd.read_csv(
                input_path,
                delimiter=&#34;\t&#34;,
                comment=&#34;#&#34;,
                index_col=index_col,
                usecols=column_headers
            )
        except ValueError as err:
            msg = &#39;Failed to read TSV from &#34;{0}&#34;. Missing required column headers &#39;.format(input_path) +\
                  &#39;from Djerba config? Pandas error message: &#34;{0}&#34;&#39;.format(err)
            self.logger.error(msg)
            raise
        if df.isnull().values.any():
            self.logger.warning(
                &#39;Null values in TSV data read from &#34;{0}&#34; &#39;.format(input_path)+\
                &#39;with column headers {0}&#39;.format(str(column_headers))
            )
        return df

    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.GENE_KEY], index_col=False)
        return df[constants.GENE_KEY].tolist()

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
            column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        metrics_by_gene = {}
        for (gene_name, row) in self._read_columns(tsv_path, column_headers).iterrows():
            # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
            # row.to_list() converts all values to Python scalars, so can be used as a workaround
            # See https://bugs.python.org/issue24313
            values = row.to_list()
            metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return metrics_by_gene

class mutation_extended(genetic_alteration):
    &#34;&#34;&#34;
    Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
    Generates reports for either cBioPortal or Elba.
    &#34;&#34;&#34;

    DATA_FILENAME = &#39;data_mutation_extended.maf&#39;
    META_FILENAME = &#39;meta_mutation_extended.txt&#39;
    BED_PATH_KEY = &#39;bed_path&#39;
    TCGA_PATH_KEY = &#39;tcga_path&#39;
    CANCER_TYPE_KEY = &#39;cancer_type&#39;

    # MAF column headers
    HUGO_SYMBOL = &#39;Hugo_Symbol&#39;
    CHROMOSOME = &#39;Chromosome&#39;

    def _find_all_sample_attributes(self):
        # TODO &#39;cancer_type&#39; appears in study-level config. Could read it from there and
        # insert into the genetic_alteration config structure, instead of having duplicate
        # values in the study-level JSON config.
        try:
            bed_path = os.path.join(self.input_directory, self.metadata[self.BED_PATH_KEY])
            tcga_path = os.path.join(self.input_directory, self.metadata[self.TCGA_PATH_KEY])
            cancer_type = self.metadata[self.CANCER_TYPE_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        for sample_id in self.sample_ids:
            maf_path = os.path.join(self.input_directory, self.input_files[sample_id])
            mx_metrics = mutation_extended_metrics(maf_path, bed_path, tcga_path, cancer_type)
            sample_attributes = {
                constants.TMB_PER_MB_KEY: mx_metrics.get_tmb()
            }
            attributes[sample_id] = sample_attributes
        return attributes
    
    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        gene_name_set = set()
        for sample_id in self.sample_ids:
            # pandas read_csv() will automatically decompress .gz input
            self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
            df = pd.read_csv(
                self.get_input_path(sample_id),
                delimiter=&#34;\t&#34;,
                usecols=[self.HUGO_SYMBOL],
                comment=&#34;#&#34;
            )
            sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
            if len(gene_name_set) == 0:
                gene_name_set = sample_gene_names
            elif sample_gene_names != gene_name_set:
                self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
        # convert to list and sort
        gene_names = sorted(list(gene_name_set))
        self.gene_names = gene_names # store the gene names in case needed later
        return gene_names

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Find gene-level mutation metrics. Chromosome name only for now; can add others.&#34;&#34;&#34;
        df = pd.read_csv(
            self.get_input_path(sample_id),
            delimiter=&#34;\t&#34;,
            usecols=[self.HUGO_SYMBOL, self.CHROMOSOME],
            comment=&#34;#&#34;
        )
        metrics_by_gene = {}
        for index, row in df.iterrows():
            metrics_by_gene[row[self.HUGO_SYMBOL]] = {self.CHROMOSOME: row[self.CHROMOSOME]}
        return metrics_by_gene

    def write_data(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation data table.

        - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
        - May enable VCF input at a later date
        - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
        - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
        &#34;&#34;&#34;
        tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
        tmp_dir = tmp.name
        #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
        input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
        uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
        commands = []
        output_paths = []
        for input_name in uncompressed:
            in_path = os.path.join(tmp_dir, input_name)
            out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
            cmd = &#34;maf2maf &#34;+\
                  &#34;--input-maf {} &#34;.format(in_path)+\
                  &#34;--output-maf {} &#34;.format(out_path)+\
                  &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
                  &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
                  &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
                  &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
            commands.append(cmd)
            output_paths.append(out_path)
        # run the maf2maf commands
        system_tools.run_subprocesses(commands, self.logger)
        # concatenate the outputs by appending to a pandas DataFrame
        output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
        for i in range(1, len(output_paths)):
            self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
            next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
            output_df = output_df.append(next_output)
        self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
        out_path = os.path.join(out_dir, self.DATA_FILENAME)
        self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
        output_df.to_csv(out_path, sep=&#34;\t&#34;)
        tmp.cleanup()

    def write_meta(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
        try:
            meta = {
                constants.STUDY_ID_KEY: self.study_id,
                constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
                constants.DATATYPE_KEY: &#39;MAF&#39;,
                constants.STABLE_ID_KEY: &#39;mutations&#39;,
                constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
                constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
                constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
                constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
            }
            # omitting optional meta keys for now:
            # - gene_panel
            # - swissprot_identifier
            # - variant_classification_filter
            # - namespaces
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
            out_file.write(yaml.dump(meta, sort_keys=True))

    def write(self, out_dir):
        self.write_data(out_dir)
        self.write_meta(out_dir)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation"><code class="flex name class">
<span>class <span class="ident">custom_annotation</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>User-defined custom annotation supplied in TSV format.</p>
<h2 id="input-requirements">Input requirements</h2>
<ul>
<li>Input is in separate TSV files for gene and sample annotation.</li>
<li>Gene and sample filenames are specified in metadata, as 'gene_tsv' and 'sample_tsv' respectively.</li>
<li>Input files are tab-delimited, and may include comment lines starting with #.</li>
<li>Annotations which contain tab characters may be enclosed in double quotes (").</li>
<li>Column headers in the gene and sample files must be specified in config metadata, as 'gene_headers' and 'sample_headers' respectively.</li>
<li>The first column must be the gene or sample identifier, with header 'Gene' or 'SAMPLE_ID' respectively.</li>
<li>If column headers from metadata are not found in the TSV file, it will raise an error.</li>
<li>Columns in the TSV file which do not appear in metadata are silently ignored.</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>Useful as a fallback for fields which cannot be automatically obtained by Djerba.</li>
<li>Currently supports Elba output only, not cBioPortal.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class custom_annotation(genetic_alteration):
    &#34;&#34;&#34;
    User-defined custom annotation supplied in TSV format.

    ## Input requirements

    - Input is in separate TSV files for gene and sample annotation.
    - Gene and sample filenames are specified in metadata, as &#39;gene_tsv&#39; and &#39;sample_tsv&#39; respectively.
    - Input files are tab-delimited, and may include comment lines starting with #.
    - Annotations which contain tab characters may be enclosed in double quotes (&#34;).
    - Column headers in the gene and sample files must be specified in config metadata, as &#39;gene_headers&#39; and &#39;sample_headers&#39; respectively.
    - The first column must be the gene or sample identifier, with header &#39;Gene&#39; or &#39;SAMPLE_ID&#39; respectively.
    - If column headers from metadata are not found in the TSV file, it will raise an error.
    - Columns in the TSV file which do not appear in metadata are silently ignored.

    ## Notes

    - Useful as a fallback for fields which cannot be automatically obtained by Djerba.
    - Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    GENE_HEADERS_KEY = &#39;gene_headers&#39;
    GENE_TSV_KEY = &#39;gene_tsv&#39;
    SAMPLE_HEADERS_KEY = &#39;sample_headers&#39;
    SAMPLE_TSV_KEY = &#39;sample_tsv&#39;

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Read attributes for each sample from a TSV file with specified headers&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
            column_headers = self.metadata[self.SAMPLE_HEADERS_KEY] # must start with SAMPLE_ID_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        # row.to_list() is a workaround for int64 conversion; see comments in get_metrics_by_gene
        for (sample_id, row) in self._read_columns(tsv_path, column_headers).iterrows():
            values = row.to_list()
            attributes[sample_id] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;Read sample IDs from TSV input file; overrides method of parent class&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.SAMPLE_ID_KEY], index_col=False)
        return df[constants.SAMPLE_ID_KEY].tolist()

    def _read_columns(self, input_path, column_headers, index_col=0):
        &#34;&#34;&#34;
        Read specified columns from TSV into a Pandas DataFrame.
        Raise an error if any requested columns are missing; warn if any values are null.
        &#34;&#34;&#34;
        try:
            df = pd.read_csv(
                input_path,
                delimiter=&#34;\t&#34;,
                comment=&#34;#&#34;,
                index_col=index_col,
                usecols=column_headers
            )
        except ValueError as err:
            msg = &#39;Failed to read TSV from &#34;{0}&#34;. Missing required column headers &#39;.format(input_path) +\
                  &#39;from Djerba config? Pandas error message: &#34;{0}&#34;&#39;.format(err)
            self.logger.error(msg)
            raise
        if df.isnull().values.any():
            self.logger.warning(
                &#39;Null values in TSV data read from &#34;{0}&#34; &#39;.format(input_path)+\
                &#39;with column headers {0}&#39;.format(str(column_headers))
            )
        return df

    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.GENE_KEY], index_col=False)
        return df[constants.GENE_KEY].tolist()

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
            column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        metrics_by_gene = {}
        for (gene_name, row) in self._read_columns(tsv_path, column_headers).iterrows():
            # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
            # row.to_list() converts all values to Python scalars, so can be used as a workaround
            # See https://bugs.python.org/issue24313
            values = row.to_list()
            metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return metrics_by_gene</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></li>
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY"><code class="name">var <span class="ident">GENE_HEADERS_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY"><code class="name">var <span class="ident">GENE_TSV_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY"><code class="name">var <span class="ident">SAMPLE_HEADERS_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY"><code class="name">var <span class="ident">SAMPLE_TSV_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene names from TSV input file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
    if self.gene_names:
        return self.gene_names
    try:
        tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
    except KeyError as err:
        self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
        raise
    df = self._read_columns(tsv_path, [constants.GENE_KEY], index_col=False)
    return df[constants.GENE_KEY].tolist()</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Read gene-level metrics from input TSV.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
    try:
        tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
    except KeyError as err:
        self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
        raise
    metrics_by_gene = {}
    for (gene_name, row) in self._read_columns(tsv_path, column_headers).iterrows():
        # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
        # row.to_list() converts all values to Python scalars, so can be used as a workaround
        # See https://bugs.python.org/issue24313
        values = row.to_list()
        metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
    return metrics_by_gene</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration"><code class="flex name class">
<span>class <span class="ident">genetic_alteration</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class; unit of genetic alteration data for cBioPortal and other reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genetic_alteration(base):
    &#34;&#34;&#34;Base class; unit of genetic alteration data for cBioPortal and other reports&#34;&#34;&#34;

    # TODO make into a Python AbstractBaseClass: https://docs.python.org/3/library/abc.html

    # top-level config keys
    WORKFLOW_RUN_ID_KEY = &#39;workflow_run_id&#39;
    METADATA_KEY = &#39;metadata&#39;
    INPUT_FILES_KEY = &#39;input_files&#39;
    INPUT_DIRECTORY_KEY = &#39;input_directory&#39;
    # additional metadata keys
    FILTER_VCF_KEY = &#39;filter_vcf&#39;
    REGIONS_BED_KEY = &#39;regions_bed&#39;
    
    def __init__(self, config, study_id=None, log_level=logging.WARNING, log_path=None):
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)
        self.study_id = study_id # required for cBioPortal, not for Elba
        try:
            self.genetic_alteration_type = config[constants.GENETIC_ALTERATION_TYPE_KEY]
            self.datatype = config[constants.DATATYPE_KEY]
            self.metadata = config[self.METADATA_KEY]
            self.input_files = config[self.INPUT_FILES_KEY]
            self.input_directory = config[self.INPUT_DIRECTORY_KEY]
            self.workflow_run_id = config[self.WORKFLOW_RUN_ID_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        self.sample_ids = self._get_sample_ids()
        self.sample_attributes = self._find_all_sample_attributes()
        # identifier for the genetic_alteration; should be unique in any given config
        self.alteration_id = &#34;%s:%s&#34; % (self.genetic_alteration_type, self.datatype)
        self.gene_names = None # used to cache the gene names

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;PLACEHOLDER. Read self.input_files and populate a sample attributes dictionary&#34;&#34;&#34;
        msg = &#34;_find_all_sample_attributes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        attributes = {}
        for sample_id in self.sample_ids:
            attributes[sample_id] = {}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;
        Find the list of sample IDs. Assumes the input_files config is non-empty.
        Optionally, can override this method in child classes.
        &#34;&#34;&#34;
        return sorted(self.input_files.keys())

    def get_alteration_id(self):
        &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
        return self.alteration_id

    def get_attributes_for_sample(self, sample_id):
        &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
        return self.sample_attributes[sample_id]

    def get_datatype(self):
        return self.datatype

    def get_genetic_alteration_type(self):
        return self.genetic_alteration_type

    def get_gene_names(self):
        &#34;&#34;&#34;
        PLACEHOLDER. Get a list of gene names from the input files.
        Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
        &#34;&#34;&#34;
        msg = &#34;get_genes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        return []

    def get_input_path(self, sample_id):
        return os.path.join(self.input_directory, self.input_files[sample_id])
    
    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
        msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
        self.logger.error(msg)
        return {}

    def get_sample_ids(self):
        return self.sample_ids</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.custom_annotation" href="#djerba.genetic_alteration.custom_annotation">custom_annotation</a></li>
<li><a title="djerba.genetic_alteration.mutation_extended" href="#djerba.genetic_alteration.mutation_extended">mutation_extended</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY"><code class="name">var <span class="ident">FILTER_VCF_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY"><code class="name">var <span class="ident">INPUT_DIRECTORY_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY"><code class="name">var <span class="ident">INPUT_FILES_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.METADATA_KEY"><code class="name">var <span class="ident">METADATA_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY"><code class="name">var <span class="ident">REGIONS_BED_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY"><code class="name">var <span class="ident">WORKFLOW_RUN_ID_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration.get_alteration_id"><code class="name flex">
<span>def <span class="ident">get_alteration_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ID defined as 'alteration_type:datatype', eg. 'MUTATION_EXTENDED:MAF'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alteration_id(self):
    &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
    return self.alteration_id</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample"><code class="name flex">
<span>def <span class="ident">get_attributes_for_sample</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Find attributes for given sample_id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes_for_sample(self, sample_id):
    &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
    return self.sample_attributes[sample_id]</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_datatype"><code class="name flex">
<span>def <span class="ident">get_datatype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datatype(self):
    return self.datatype</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PLACEHOLDER. Get a list of gene names from the input files.
Not run from <strong>init</strong>() because it can be quite slow (eg. reading multiple MAF files).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;
    PLACEHOLDER. Get a list of gene names from the input files.
    Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
    &#34;&#34;&#34;
    msg = &#34;get_genes method of parent class; not intended for production&#34;
    self.logger.error(msg)
    return []</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type"><code class="name flex">
<span>def <span class="ident">get_genetic_alteration_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_genetic_alteration_type(self):
    return self.genetic_alteration_type</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_input_path"><code class="name flex">
<span>def <span class="ident">get_input_path</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_path(self, sample_id):
    return os.path.join(self.input_directory, self.input_files[sample_id])</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
    msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
    self.logger.error(msg)
    return {}</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_sample_ids"><code class="name flex">
<span>def <span class="ident">get_sample_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_ids(self):
    return self.sample_ids</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.utilities.base.base.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration_factory"><code class="flex name class">
<span>class <span class="ident">genetic_alteration_factory</span></span>
<span>(</span><span>log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genetic_alteration_factory(base):
    &#34;&#34;&#34;Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE&#34;&#34;&#34;

    CLASSNAMES = {
        constants.CUSTOM_ANNOTATION_TYPE: &#39;custom_annotation&#39;,
        constants.MUTATION_TYPE: &#39;mutation_extended&#39;
    }

    def __init__(self, log_level=logging.WARN, log_path=None):
        self.log_level = log_level
        self.log_path = log_path
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)

    def create_instance(self, config, study_id=None):
        &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
        alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
        classname = self.CLASSNAMES.get(alteration_type)
        if alteration_type == None or classname == None:
            msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
            msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
            self.logger.error(msg)
            raise ValueError(msg)
        klass = globals().get(classname)
        return klass(config, study_id, self.log_level, self.log_path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES"><code class="name">var <span class="ident">CLASSNAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration_factory.create_instance"><code class="name flex">
<span>def <span class="ident">create_instance</span></span>(<span>self, config, study_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the genetic_alteration class named in the config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_instance(self, config, study_id=None):
    &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
    alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
    classname = self.CLASSNAMES.get(alteration_type)
    if alteration_type == None or classname == None:
        msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
        msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
        self.logger.error(msg)
        raise ValueError(msg)
    klass = globals().get(classname)
    return klass(config, study_id, self.log_level, self.log_path)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.utilities.base.base.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended"><code class="flex name class">
<span>class <span class="ident">mutation_extended</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
Generates reports for either cBioPortal or Elba.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mutation_extended(genetic_alteration):
    &#34;&#34;&#34;
    Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
    Generates reports for either cBioPortal or Elba.
    &#34;&#34;&#34;

    DATA_FILENAME = &#39;data_mutation_extended.maf&#39;
    META_FILENAME = &#39;meta_mutation_extended.txt&#39;
    BED_PATH_KEY = &#39;bed_path&#39;
    TCGA_PATH_KEY = &#39;tcga_path&#39;
    CANCER_TYPE_KEY = &#39;cancer_type&#39;

    # MAF column headers
    HUGO_SYMBOL = &#39;Hugo_Symbol&#39;
    CHROMOSOME = &#39;Chromosome&#39;

    def _find_all_sample_attributes(self):
        # TODO &#39;cancer_type&#39; appears in study-level config. Could read it from there and
        # insert into the genetic_alteration config structure, instead of having duplicate
        # values in the study-level JSON config.
        try:
            bed_path = os.path.join(self.input_directory, self.metadata[self.BED_PATH_KEY])
            tcga_path = os.path.join(self.input_directory, self.metadata[self.TCGA_PATH_KEY])
            cancer_type = self.metadata[self.CANCER_TYPE_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        for sample_id in self.sample_ids:
            maf_path = os.path.join(self.input_directory, self.input_files[sample_id])
            mx_metrics = mutation_extended_metrics(maf_path, bed_path, tcga_path, cancer_type)
            sample_attributes = {
                constants.TMB_PER_MB_KEY: mx_metrics.get_tmb()
            }
            attributes[sample_id] = sample_attributes
        return attributes
    
    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        gene_name_set = set()
        for sample_id in self.sample_ids:
            # pandas read_csv() will automatically decompress .gz input
            self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
            df = pd.read_csv(
                self.get_input_path(sample_id),
                delimiter=&#34;\t&#34;,
                usecols=[self.HUGO_SYMBOL],
                comment=&#34;#&#34;
            )
            sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
            if len(gene_name_set) == 0:
                gene_name_set = sample_gene_names
            elif sample_gene_names != gene_name_set:
                self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
        # convert to list and sort
        gene_names = sorted(list(gene_name_set))
        self.gene_names = gene_names # store the gene names in case needed later
        return gene_names

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Find gene-level mutation metrics. Chromosome name only for now; can add others.&#34;&#34;&#34;
        df = pd.read_csv(
            self.get_input_path(sample_id),
            delimiter=&#34;\t&#34;,
            usecols=[self.HUGO_SYMBOL, self.CHROMOSOME],
            comment=&#34;#&#34;
        )
        metrics_by_gene = {}
        for index, row in df.iterrows():
            metrics_by_gene[row[self.HUGO_SYMBOL]] = {self.CHROMOSOME: row[self.CHROMOSOME]}
        return metrics_by_gene

    def write_data(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation data table.

        - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
        - May enable VCF input at a later date
        - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
        - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
        &#34;&#34;&#34;
        tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
        tmp_dir = tmp.name
        #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
        input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
        uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
        commands = []
        output_paths = []
        for input_name in uncompressed:
            in_path = os.path.join(tmp_dir, input_name)
            out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
            cmd = &#34;maf2maf &#34;+\
                  &#34;--input-maf {} &#34;.format(in_path)+\
                  &#34;--output-maf {} &#34;.format(out_path)+\
                  &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
                  &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
                  &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
                  &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
            commands.append(cmd)
            output_paths.append(out_path)
        # run the maf2maf commands
        system_tools.run_subprocesses(commands, self.logger)
        # concatenate the outputs by appending to a pandas DataFrame
        output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
        for i in range(1, len(output_paths)):
            self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
            next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
            output_df = output_df.append(next_output)
        self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
        out_path = os.path.join(out_dir, self.DATA_FILENAME)
        self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
        output_df.to_csv(out_path, sep=&#34;\t&#34;)
        tmp.cleanup()

    def write_meta(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
        try:
            meta = {
                constants.STUDY_ID_KEY: self.study_id,
                constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
                constants.DATATYPE_KEY: &#39;MAF&#39;,
                constants.STABLE_ID_KEY: &#39;mutations&#39;,
                constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
                constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
                constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
                constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
            }
            # omitting optional meta keys for now:
            # - gene_panel
            # - swissprot_identifier
            # - variant_classification_filter
            # - namespaces
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
            out_file.write(yaml.dump(meta, sort_keys=True))

    def write(self, out_dir):
        self.write_data(out_dir)
        self.write_meta(out_dir)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></li>
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.mutation_extended.BED_PATH_KEY"><code class="name">var <span class="ident">BED_PATH_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY"><code class="name">var <span class="ident">CANCER_TYPE_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.CHROMOSOME"><code class="name">var <span class="ident">CHROMOSOME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.DATA_FILENAME"><code class="name">var <span class="ident">DATA_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.HUGO_SYMBOL"><code class="name">var <span class="ident">HUGO_SYMBOL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.META_FILENAME"><code class="name">var <span class="ident">META_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY"><code class="name">var <span class="ident">TCGA_PATH_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.mutation_extended.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene names from the input MAF files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
    if self.gene_names:
        return self.gene_names
    gene_name_set = set()
    for sample_id in self.sample_ids:
        # pandas read_csv() will automatically decompress .gz input
        self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
        df = pd.read_csv(
            self.get_input_path(sample_id),
            delimiter=&#34;\t&#34;,
            usecols=[self.HUGO_SYMBOL],
            comment=&#34;#&#34;
        )
        sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
        if len(gene_name_set) == 0:
            gene_name_set = sample_gene_names
        elif sample_gene_names != gene_name_set:
            self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
    # convert to list and sort
    gene_names = sorted(list(gene_name_set))
    self.gene_names = gene_names # store the gene names in case needed later
    return gene_names</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene-level mutation metrics. Chromosome name only for now; can add others.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;Find gene-level mutation metrics. Chromosome name only for now; can add others.&#34;&#34;&#34;
    df = pd.read_csv(
        self.get_input_path(sample_id),
        delimiter=&#34;\t&#34;,
        usecols=[self.HUGO_SYMBOL, self.CHROMOSOME],
        comment=&#34;#&#34;
    )
    metrics_by_gene = {}
    for index, row in df.iterrows():
        metrics_by_gene[row[self.HUGO_SYMBOL]] = {self.CHROMOSOME: row[self.CHROMOSOME]}
    return metrics_by_gene</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, out_dir):
    self.write_data(out_dir)
    self.write_meta(out_dir)</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write_data"><code class="name flex">
<span>def <span class="ident">write_data</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>cBioPortal. Write mutation data table.</p>
<ul>
<li>Read mutation data in MAF format and output in cBioPortal's required MAF format</li>
<li>May enable VCF input at a later date</li>
<li>see <a href="https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data">https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data</a></li>
<li>required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_data(self, out_dir):
    &#34;&#34;&#34;cBioPortal. Write mutation data table.

    - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
    - May enable VCF input at a later date
    - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
    - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
    &#34;&#34;&#34;
    tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
    tmp_dir = tmp.name
    #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
    input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
    uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
    commands = []
    output_paths = []
    for input_name in uncompressed:
        in_path = os.path.join(tmp_dir, input_name)
        out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
        cmd = &#34;maf2maf &#34;+\
              &#34;--input-maf {} &#34;.format(in_path)+\
              &#34;--output-maf {} &#34;.format(out_path)+\
              &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
              &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
              &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
              &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
        commands.append(cmd)
        output_paths.append(out_path)
    # run the maf2maf commands
    system_tools.run_subprocesses(commands, self.logger)
    # concatenate the outputs by appending to a pandas DataFrame
    output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
    self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
    for i in range(1, len(output_paths)):
        self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
        next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        output_df = output_df.append(next_output)
    self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
    out_path = os.path.join(out_dir, self.DATA_FILENAME)
    self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
    output_df.to_csv(out_path, sep=&#34;\t&#34;)
    tmp.cleanup()</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write_meta"><code class="name flex">
<span>def <span class="ident">write_meta</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>cBioPortal. Write mutation metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_meta(self, out_dir):
    &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
    try:
        meta = {
            constants.STUDY_ID_KEY: self.study_id,
            constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
            constants.DATATYPE_KEY: &#39;MAF&#39;,
            constants.STABLE_ID_KEY: &#39;mutations&#39;,
            constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
            constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
            constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
            constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
        }
        # omitting optional meta keys for now:
        # - gene_panel
        # - swissprot_identifier
        # - variant_classification_filter
        # - namespaces
    except KeyError as err:
        self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
        raise
    with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
        out_file.write(yaml.dump(meta, sort_keys=True))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="djerba" href="index.html">djerba</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="djerba.genetic_alteration.custom_annotation" href="#djerba.genetic_alteration.custom_annotation">custom_annotation</a></code></h4>
<ul class="two-column">
<li><code><a title="djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY" href="#djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY">GENE_HEADERS_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY" href="#djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY">GENE_TSV_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY" href="#djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY">SAMPLE_HEADERS_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY" href="#djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY">SAMPLE_TSV_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.get_gene_names" href="#djerba.genetic_alteration.custom_annotation.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.get_metrics_by_gene" href="#djerba.genetic_alteration.custom_annotation.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code></h4>
<ul class="">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY" href="#djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY">FILTER_VCF_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY" href="#djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY">INPUT_DIRECTORY_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY" href="#djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY">INPUT_FILES_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.METADATA_KEY" href="#djerba.genetic_alteration.genetic_alteration.METADATA_KEY">METADATA_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY" href="#djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY">REGIONS_BED_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY" href="#djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY">WORKFLOW_RUN_ID_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_datatype" href="#djerba.genetic_alteration.genetic_alteration.get_datatype">get_datatype</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_gene_names" href="#djerba.genetic_alteration.genetic_alteration.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type" href="#djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type">get_genetic_alteration_type</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_input_path" href="#djerba.genetic_alteration.genetic_alteration.get_input_path">get_input_path</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene" href="#djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_sample_ids" href="#djerba.genetic_alteration.genetic_alteration.get_sample_ids">get_sample_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.genetic_alteration_factory" href="#djerba.genetic_alteration.genetic_alteration_factory">genetic_alteration_factory</a></code></h4>
<ul class="">
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES" href="#djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES">CLASSNAMES</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory.create_instance" href="#djerba.genetic_alteration.genetic_alteration_factory.create_instance">create_instance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.mutation_extended" href="#djerba.genetic_alteration.mutation_extended">mutation_extended</a></code></h4>
<ul class="two-column">
<li><code><a title="djerba.genetic_alteration.mutation_extended.BED_PATH_KEY" href="#djerba.genetic_alteration.mutation_extended.BED_PATH_KEY">BED_PATH_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY" href="#djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY">CANCER_TYPE_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.CHROMOSOME" href="#djerba.genetic_alteration.mutation_extended.CHROMOSOME">CHROMOSOME</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.DATA_FILENAME" href="#djerba.genetic_alteration.mutation_extended.DATA_FILENAME">DATA_FILENAME</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.HUGO_SYMBOL" href="#djerba.genetic_alteration.mutation_extended.HUGO_SYMBOL">HUGO_SYMBOL</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.META_FILENAME" href="#djerba.genetic_alteration.mutation_extended.META_FILENAME">META_FILENAME</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY" href="#djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY">TCGA_PATH_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.get_gene_names" href="#djerba.genetic_alteration.mutation_extended.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.get_metrics_by_gene" href="#djerba.genetic_alteration.mutation_extended.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write" href="#djerba.genetic_alteration.mutation_extended.write">write</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write_data" href="#djerba.genetic_alteration.mutation_extended.write_data">write_data</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write_meta" href="#djerba.genetic_alteration.mutation_extended.write_meta">write_meta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>